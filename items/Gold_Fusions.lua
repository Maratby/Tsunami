---{C:tsun_gold1}{C:tsun_gold2}{C:tsun_gold3}{C:tsun_gold4}{C:tsun_gold5}{C:tsun_gold4}{C:tsun_gold3}{C:tsun_gold2}

---Gold Fusion Rarity
SMODS.Rarity {
	key = "tsun_gold_fusion",
	default_weight = 0,
	badge_colour = HEX("d8b162"),
	pools = { ["Joker"] = false },
	get_weight = function(self, weight, object_type)
		return weight
	end,
}


SMODS.Joker {
	key = "gold_splish_splash",
	rarity = "tsun_gold_fusion",
	cost = 15,
	unlocked = true,
	discovered = true,
	blueprint_compat = true,
	eternal_compat = true,
	perishable_compat = true,
	---Cryptid config thingy to disable the Joker from being generated by Ace Equillibrium
	no_aeq = true,
	atlas = "Tsunami",
	pos = { x = 0, y = 17 },
	ability_name = "Gold Splish Splash",
	calculate = function(self, card, context)
		if context.setting_blind then
			local splishcard = create_card("Joker", G.jokers, nil, nil, nil, nil, "j_splash")
			splishcard:add_to_deck()
			splishcard:set_edition({ negative = true })
			G.jokers:emplace(splishcard)
		end
	end
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_tsun_splish_splash" },
    { name = "j_splash" },
  }, cost = 15, result_joker = "j_tsun_gold_splish_splash"
}

SMODS.Joker {
	key = "gold_reflection",
	rarity = "tsun_gold_fusion",
	cost = 30,
	config = { extra = 1.3, clubs = 0, nonclubs = 0, mult_from_clubs = 1 },
	loc_vars = function(self, info_queue, card)
		return { vars = { card.ability.extra } }
	end,
	unlocked = true,
	discovered = true,
	blueprint_compat = true,
	eternal_compat = true,
	perishable_compat = true,
	no_aeq = true,
	atlas = "Tsunami",
	pos = { x = 1, y = 17 },
	ability_name = "Gold Reflection",
	calculate = function(self, card, context)
		if context.individual and context.cardarea == G.play and not context.blueprint then
			card.ability.mult_from_clubs = 1
			local scoredflag = false
			local increase = 1
			if card_is_splashed(context.other_card) then
				increase = 2
			end
			if not context.other_card.debuff then
				if context.other_card.ability.name == 'Wild Card' then
					card.ability.clubs = card.ability.clubs + increase
					card.ability.nonclubs = card.ability.nonclubs + increase
				elseif context.other_card:is_suit("Clubs") then
					card.ability.clubs = card.ability.clubs + increase
				else
					card.ability.nonclubs = card.ability.nonclubs + increase
				end
			end
			local clubinstances = math.min(card.ability.clubs, card.ability.nonclubs)
			if clubinstances ~= 0 then
				for k = 1, clubinstances, 1 do
					card.ability.mult_from_clubs = card.ability.mult_from_clubs * card.ability.extra
				end
			end
		end
		if context.joker_main then
			card.ability.clubs = 0
			card.ability.nonclubs = 0
			if card.ability.mult_from_clubs > 1 then
				return {
					message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.mult_from_clubs } },
					Xmult_mod = card.ability.mult_from_clubs,
					card = card,
				}
			end
		end
	end
}
FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_tsun_reflection" },
    { name = "j_splash" },
  }, cost = 20, result_joker = "j_tsun_gold_reflection"
}

SMODS.Joker {
	key = "gold_cryomancer",
	rarity = "tsun_gold_fusion",
	cost = 15,
	config = { extra = 1 },
	loc_vars = function(self, info_queue, card)
		info_queue[#info_queue + 1] = G.P_CENTERS.j_splash
		return { vars = { card.ability.extra } }
	end,
	unlocked = true,
	discovered = true,
	blueprint_compat = true,
	eternal_compat = true,
	perishable_compat = true,
	---Cryptid config thingy to disable the Joker from being generated by Ace Equillibrium
	no_aeq = true,
	atlas = "Tsunami",
	pos = { x = 3, y = 17 },
	ability_name = "Gold Cryomancer",
	add_to_deck = function(self, card, from_debuff)
		G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra
	end,
	remove_from_deck = function(self, card, from_debuff)
		G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra
	end,
	calculate = function(self, card, context)
		if context.setting_blind then
			if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
				G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
				G.E_MANAGER:add_event(Event({
					blockable = true,
					blocking = true,
					func = function()
						local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
						tarotcard:add_to_deck()
						G.consumeables:emplace(tarotcard)
						card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
							{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
						G.GAME.consumeable_buffer = G.GAME.consumeable_buffer - 1
						return true
					end
				}))
			end
		end
		if context.end_of_round and not context.bluepirnt and context.main_eval and G.jokers and G.jokers.cards[#G.jokers.cards].config.center.key == "j_splash" then
			if not G.jokers.cards[#G.jokers.cards].ability.eternal then
				local killsplash = G.jokers.cards[#G.jokers.cards]
				if killsplash.edition then
					G.E_MANAGER:add_event(Event({
						blockable = true,
						blocking = true,
						func = function()
							local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
							tarotcard:set_edition({ negative = true }, nil)
							tarotcard:add_to_deck()
							G.consumeables:emplace(tarotcard)
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
								{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
							return true
						end
					}))
				end
				killsplash:start_dissolve()
				G.E_MANAGER:add_event(Event({
					blockable = true,
					blocking = true,
					func = function()
						local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
						tarotcard:set_edition({ negative = true }, nil)
						tarotcard:add_to_deck()
						G.consumeables:emplace(tarotcard)
						card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
							{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
						return true
					end
				}))
			end
		end
	end
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_tsun_cryomancer" },
    { name = "j_splash" },
  }, cost = 14, result_joker = "j_tsun_gold_cryomancer"
}

SMODS.Joker {
	key = 'gold_holy_water',
	atlas = "Tsunami",
	rarity = "tsun_gold_fusion",
	unlocked = true,
	cost = 20,
	discovered = true,
	config = { mult = 20 },
	pos = { x = 2, y = 17 },
	remove_from_deck = function(self, card, from_debuff)
		G.hand:unhighlight_all()
	end,
	loc_vars = function(self, info_queue, card)
		return { vars = { card.ability.mult } }
	end,
	calculate = function(self, card, context)
		if context.joker_main and next(context.poker_hands['Pair']) then
			return {
				mult = card.ability.mult
			}
		end
	end,
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = 'j_tsun_holy_water' },
    { name = 'j_splash' },
  }, cost = 10, result_joker = 'j_tsun_gold_holy_water'
}


SMODS.Joker {
	key = "gold_asset_liquidation",
	name = "Asset Liquidation",
	rarity = "tsun_gold_fusion",
	unlocked = true,
	discovered = true,
	blueprint_compat = true,
	atlas = "Tsunami",
	pos = { x = 5, y = 17 },
	cost = -10,
	config = { triggers = 5, triggersmax = 5, storage = 0 },
	ability_name = "mooney_laundering",
	loc_vars = function(self, info_queue, card)
		return { vars = { card.ability.triggers, card.ability.triggersmax, card.ability.storage } }
	end,
	calculate = function(self, card, context)
		if context.setting_blind then
			local temphands = 3 + card.ability.storage / 10
			if Tsunami_Config.TsunRounding then
				temphands = math.floor(temphands)
			end
			ease_hands_played(math.max(3, temphands))
			ease_discard(-G.GAME.round_resets.discards)
		end
		if context.money_altered and context.amount < 0 and card.ability.triggers > 0 then
			card:juice_up()
			local tempdollar = context.amount / -2
			if Tsunami_Config.TsunRounding then
				tempdollar = math.floor(tempdollar + 0.5)
			else
				tempdollar = math.floor(tempdollar)
			end
			card.ability.triggers = card.ability.triggers - 1
			---storing saved amount
			card.ability.storage = card.ability.storage + tempdollar
			ease_dollars(tempdollar)
		end
		if context.end_of_round and context.beat_boss and context.main_eval then
			card.ability.triggers = 5
			return {
				card = card,
				message = localize('k_reset')
			}
		end
	end
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_splash" },
    { name = "j_tsun_asset_liquidation", carry_stat = "storage" },
  }, cost = 20, result_joker = "j_tsun_gold_asset_liquidation"
}

--- Mostly an addition for the high-scoring massively overpowered Balatro Enjoyers.
GMinfolist = {
	"goldmarie_whitestake",
	"goldmarie_redstake",
	"goldmarie_greenstake",
	"goldmarie_blackstake",
	"goldmarie_bluestake",
	"goldmarie_purplestake",
	"goldmarie_orangestake",
	"goldmarie_goldstake"
}
GYo_infolist = {
	"goldyosuke_whitestake",
	"goldyosuke_redstake",
	"goldyosuke_greenstake",
	"goldyosuke_blackstake",
	"goldyosuke_bluestake",
	"goldyosuke_purplestake",
	"goldyosuke_orangestake",
	"goldyosuke_goldstake"
}
GR_infolist = {
	"goldrise_whitestake",
	"goldrise_redstake",
	"goldrise_greenstake",
	"goldrise_blackstake",
	"goldrise_bluestake",
	"goldrise_purplestake",
	"goldrise_orangestake",
	"goldrise_goldstake"
}

GC_infolist = {
	"goldchie_whitestake",
	"goldchie_redstake",
	"goldchie_greenstake",
	"goldchie_blackstake",
	"goldchie_bluestake",
	"goldchie_purplestake",
	"goldchie_orangestake",
	"goldchie_goldstake"
}
---Sent to card_is_splashed for extra scored card calculation in Gold Marie's Red Stake effect.
GMAllExtra = false
---Sent to the Aeon Tarot Card to activate double-splash spawning.
AeonDoubleSplash = false

SMODS.Joker {
	name = "Marie",
	key = "gold_tsunami_marie",
	rarity = "tsun_gold_legendary",
	cost = 50,
	unlocked = true,
	discovered = false,
	blueprint_compat = false,
	eternal_compat = true,
	perishable_compat = false,
	no_aeq = true,

	config = { extra = {
		--- Base effect Xmult
		base = 2,
		--- Key of Splash's Stake Sticker
		stickerkey = "none, you suck",
		sticker = 0,
		retriggers = 1,
		tally = 0,
		basegoldxmult = 1.5,
		goldxmult = 1.5,
	} },
	atlas = "TsunamiGoldLegendary",
	pos = { x = 1, y = 0 },
	soul_pos = { x = 1, y = 1 },
	ability_name = "Gold Marie",
	loc_vars = function(self, info_queue, card)
		for i = 1, 8 do
			info_queue[#info_queue + 1] = {
				key = GMinfolist[i],
				set = 'Other',
			}
		end
		return { vars = { card.ability.extra.base, card.ability.extra.stickerkey, card.ability.extra.sticker } }
	end,
	set_ability = function(self, card, initial, delay_sprites)
		card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_splash)
		card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_splash)
		if card.ability.extra.sticker >= 6 then
			card.ability.extra.base = card.ability.extra.base * 1.5
		end
	end,
	add_to_deck = function(self, card, from_debuff)
		if card.ability.extra.sticker >= 2 then
			GMAllExtra = true
		end
		if card.ability.extra.sticker >= 3 then
			AeonDoubleSplash = true
		end
		if card.ability.extra.sticker >= 4 and not from_debuff then
			card:set_edition({ negative = true })
			card:set_eternal(true)
		end
	end,
	remove_from_deck = function(self, card, from_debuff)
		if card.ability.extra.sticker >= 3 then
			AeonDoubleSplash = false
		end
		GMAllExtra = false
	end,
	calculate = function(self, card, context)
		GY_IExist = false
		---lazy updating values so they get reapplied when exiting and re-entering a run
		if card.ability.extra.sticker >= 2 then
			GMAllExtra = true
		end
		if card.ability.extra.sticker >= 3 then
			AeonDoubleSplash = true
		end

		---base marie effect
		if not context.blueprint then
			if context.other_joker then
				if (context.other_joker.config.center.mod and context.other_joker.config.center.mod.id == "Tsunami" and self ~= context.other_joker)
					or ((context.other_joker.config.center.key == "j_splash" or context.other_joker.config.center.key == "j_evo_ripple")) then
					return {
						message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.base } },
						Xmult_mod = card.ability.extra.base,
						card = context.other_joker,
					}
				end
			end
			if context.repetition and context.cardarea == G.play and card.ability.extra.sticker >= 2 then
				if card_is_splashed(context.other_card) then
					context.other_card:set_ability(G.P_CENTERS.m_tsun_waterproof)
				end
			end
			if context.end_of_round and context.main_eval and not context.repetition and not context.individual and card.ability.extra.sticker >= 4 then
				for index, value in ipairs(G.jokers.cards) do
					if value.config.center.key == "j_splash" and not value.edition then
						value:set_edition({ negative = true })
					end
				end
			end
			if context.end_of_round and context.main_eval and not context.game_over then
				if card.ability.extra.sticker >= 1 then
					if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
						G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
						G.E_MANAGER:add_event(Event({
							trigger = 'before',
							delay = 0.0,
							func = (function()
								SMODS.add_card({ area = G.consumeables, key = "c_tsun_aeon" })
								G.GAME.consumeable_buffer = 0
								return true
							end)
						}))
						return {
							message = localize('k_plus_tarot'),
							colour = G.C.SECONDARY_SET.Tarot,
							card = card
						}
					end
				end
			end
			if context.individual and context.cardarea == G.play and card.ability.extra.sticker >= 8 then
				card.ability.extra.tally = 0
				card.ability.extra.goldxmult = card.ability.extra.basegoldxmult
				for index, value in ipairs(G.jokers.cards) do
					if value.config.center.key == "j_splash" or (value.config.center.mod and value.config.center.mod.id == "Tsunami") then
						card.ability.extra.tally = card.ability.extra.tally + 1
					end
				end
				card.ability.extra.goldxmult = card.ability.extra.basegoldxmult ^ card.ability.extra.tally
				if card.ability.extra.tally > 0 and card_is_splashed(context.other_card) then
					return {
						x_mult = card.ability.extra.goldxmult,
						card = context.other_card
					}
				end
			end
			if card.ability.extra.sticker >= 5 and context.game_over and not context.repetition and not context.individual and G.GAME.chips / G.GAME.blind.chips >= to_big(0.25) then
				local splashflag = false
				local killflag = true
				for index, value in ipairs(G.jokers.cards) do
					if value.config.center.key == "j_splash" or value.config.center.key == "j_evo_ripple" then
						splashflag = true
					else
						splashflag = false
					end
				end
				if splashflag == true then
					G.E_MANAGER:add_event(Event({
						func = function()
							G.hand_text_area.blind_chips:juice_up()
							G.hand_text_area.game_chips:juice_up()
							play_sound('tarot1')
							return true
						end
					}))
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" or value.config.center.key == "j_evo_ripple" then
							if value.ability.eternal then
								value.ability.eternal = false
							else
								if killflag == true then
									value:start_dissolve()
									killflag = false
								end
							end
						end
					end
					return {
						message = localize('k_saved_ex'),
						saved = "k_mariesave",
						colour = G.C.RED
					}
				end
			end
		end
	end
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_splash" },
    { name = "j_tsun_tsunami_marie" },
  }, cost = 50, result_joker = "j_tsun_gold_tsunami_marie"
}


GY_IExist = false
SMODS.Joker {
	name = "Yosuke",
	key = "gold_tsunami_yosuke",
	rarity = "tsun_gold_legendary",
	cost = 50,
	unlocked = true,
	discovered = false,
	blueprint_compat = false,
	eternal_compat = true,
	perishable_compat = false,
	no_aeq = true,
	config = { extra = {
		x_mult = 1,
		count = 0,
		countmax = 20,
		gain = 1,
		---Probcount value no longer needed due to new probability changes
		sticker = 0,
		stickerkey = "none",
	} },
	atlas = "TsunamiGoldLegendary",
	pos = { x = 2, y = 0 },
	soul_pos = { x = 2, y = 1 },
	loc_vars = function(self, info_queue, card)
		for i = 1, 8 do
			info_queue[#info_queue + 1] = {
				key = GYo_infolist[i],
				set = 'Other',
			}
		end
		return { vars = { card.ability.extra.x_mult, card.ability.extra.count, card.ability.extra.countmax, card.ability.extra.gain, card.ability.extra.sticker, card.ability.extra.stickerkey } }
	end,
	set_ability = function(self, card, initial, delay_sprites)
		card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_tsun_tsunami_chie)
		card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_tsun_tsunami_chie)
		if card.ability.extra.sticker >= 6 then
			card.ability.extra.x_mult = card.ability.extra.x_mult * 2
			card.ability.extra.gain = card.ability.extra.gain * 2
		end
	end,
	add_to_deck = function(self, card, from_debuff)
		if card.ability.extra.x_mult == 1 and card.ability.x_mult then
			card.ability.extra.x_mult = card.ability.x_mult
			card.ability.x_mult = 1
		end
		if card.ability.extra.sticker >= 4 and not from_debuff then
			card:set_edition({ negative = true })
			card:set_eternal(true)
		end
		if card.ability.extra.sticker >= 5 then
			G.GAME.modifiers.extra_boosters = (G.GAME.modifiers.extra_boosters or 0) + 1
			if G.shop_booster and G.shop_booster.cards then
				G.shop_booster.config.card_limit = G.GAME.starting_params.boosters_in_shop +
					(G.GAME.modifiers.extra_boosters or 0)
				for i = #G.shop_booster.cards + 1, G.shop_booster.config.card_limit do
					G.GAME.current_round.used_packs[i] = get_pack('shop_pack').key
					local card = Card(G.shop_booster.T.x + G.shop_booster.T.w / 2,
						G.shop_booster.T.y, G.CARD_W * 1.27, G.CARD_H * 1.27, G.P_CARDS.empty,
						G.P_CENTERS[G.GAME.current_round.used_packs[i]],
						{ bypass_discovery_center = true, bypass_discovery_ui = true })
					create_shop_card_ui(card, 'Booster', G.shop_booster)
					card.ability.booster_pos = i
					G.shop_booster:emplace(card)
				end
			end
		end
		if card.ability.extra.sticker >= 6 then
			change_shop_size(1)
		end
	end,
	remove_from_deck = function(self, card, from_debuff)
		if card.ability.extra.sticker >= 5 then
			G.GAME.modifiers.extra_boosters = math.max(G.GAME.modifiers.extra_boosters - 1, 0)
		end
		if card.ability.extra.sticker >= 6 then
			change_shop_size(-1)
		end
		if not from_debuff and not G.CONTROLLER.locks.selling_card then
			check_for_unlock { type = "tsun_dragontrial" }
		end
	end,
	calculate = function(self, card, context)
		---New probability stuff
		if context.mod_probability and not context.blueprint then
			if card.ability.extra.sticker >= 4 then
				return {
					numerator = (context.numerator + 1) * 2
				}
			elseif card.ability.extra.sticker >= 3 then
				return {
					numerator = context.numerator + 1
				}
			end
		end

		if not context.blueprint then
			---base Yosuke effect
			if context.before then
				for index, value in ipairs(G.play.cards) do
					if card_is_splashed(value) == true then
						card.ability.extra.count = card.ability.extra.count +
							(1 * math.max(0, G.GAME.current_round.discards_left))
						if card.ability.extra.count >= card.ability.extra.countmax then
							card_eval_status_text(card, 'extra', nil, nil, nil,
								{ message = localize('k_upgrade_ex'), colour = G.C.ATTENTION })
							card.ability.extra.x_mult = card.ability.extra.x_mult + 1
							card.ability.extra.count = card.ability.extra.count - card.ability.extra.countmax
						end
					end
				end
			end
			if context.individual and context.cardarea == G.play then
				if card.ability.extra.count >= card.ability.extra.countmax then
					card_eval_status_text(card, 'extra', nil, nil, nil,
						{ message = localize('k_upgrade_ex'), colour = G.C.ATTENTION })
					card.ability.extra.x_mult = card.ability.extra.x_mult + 1
					card.ability.extra.count = card.ability.extra.count - card.ability.extra.countmax
				end
			end
			if context.joker_main then
				return {
					message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
					Xmult_mod = card.ability.extra.x_mult,
				}
			end
			if context.end_of_round and context.main_eval and not context.game_over then
				if card.ability.extra.sticker >= 2 then
					card.ability.extra.count = card.ability.extra.count +
						math.max(0, G.GAME.current_round.discards_left)
				end
				if card.ability.extra.sticker >= 1 then
					if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
						G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
						G.E_MANAGER:add_event(Event({
							trigger = 'before',
							delay = 0.0,
							func = (function()
								SMODS.add_card({ area = G.consumeables, key = "c_magician" })
								G.GAME.consumeable_buffer = 0
								return true
							end)
						}))
						return {
							message = localize('k_plus_tarot'),
							colour = G.C.SECONDARY_SET.Tarot,
							card = card
						}
					end
				end
			end
			if G.GAME.shop and card.ability.extra.sticker >= 5 then
				if G.shop_booster and G.shop_booster.cards then
					for _, booster in ipairs(G.shop_booster.cards) do
						if not booster.yosuke_hit then
							booster.ability.extra = (booster.ability.extra or 1) + 1
							booster.ability.choose = (booster.ability.choose or 1) + 1
							booster.yosuke_hit = true
						end
					end
				end
			end
			if context.buying_card and card.ability.extra.sticker >= 7 then
				if not context.card.edition then
					context.card:set_edition(poll_edition("yosuke", nil, true, true,
						{ "e_foil", "e_holo", "e_polychrome", "e_negative" }))
				end
			end
		end
	end
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_splash" },
    { name = "j_tsun_tsunami_yosuke", carry_stat = "x_mult" },
  }, cost = 50, result_joker = "j_tsun_gold_tsunami_yosuke"
}



--- Gold rise...
--- Ffffucking hell this is gonna be a nightmare

RS_pokerhand = "High Card"
SMODS.Joker {
	key = "gold_tsunami_rise",
	rarity = "tsun_gold_legendary",
	cost = 50,
	unlocked = true,
	discovered = true,
	blueprint_compat = false,
	eternal_compat = true,
	perishable_compat = false,
	---Cryptid config things
	immutable = true,
	no_aeq = true,

	config = { gold = {
		---Gold Fusion Values
		sticker = 0,
		stickerkey = "None! You can do this!",
		boss_xmult = 10,
		odds = 4,
		handbonus = 2,
		wild_retriggers = 0,
		skips = 0,
		skipmax = 4,
		bossblind = false,
	} },

	atlas = "TsunamiGoldLegendary",
	pos = { x = 3, y = 0 },
	soul_pos = { x = 3, y = 1 },
	loc_vars = function(self, info_queue, card)
		local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.gold.odds,
			'tsun_gold_rise')
		for i = 1, 8 do
			info_queue[#info_queue + 1] = {
				key = GR_infolist[i],
				set = 'Other',
				vars = { card.ability.gold.wild_retriggers, card.ability.gold.skips, card.ability.gold.skipmax, new_numerator, new_denominator }
			}
		end
		return { vars = { card.ability.extra.last_buff, card.ability.extra.random, card.ability.gold.stickerkey, card.ability.gold.sticker, card.ability.extra.base_xmult } }
	end,
	calc_dollar_bonus = function(self, card)
		local bonus = card.ability.extra.money * G.GAME.round_resets.ante
		if bonus > 0 then
			return G.GAME.blind.boss and bonus or nil
		end
	end,
	set_ability = function(self, card, initial, delay_sprites)
		card.ability.extra = Tsunami_Rise_Transfer or {
			last_buff = "None",
			random = "",
			money = 0,
			interval = 1,
			planets = 0,
			triggers = { Hearts = 0, Spades = 0, Diamonds = 0, Clubs = 0 },
			xmult_toggle = 0,
			bossblind = true,
		}
		Tsunami_Rise_Transfer = nil

		card.ability.gold.sticker = sticker_inquisition(G.P_CENTERS.j_tsun_tsunami_yu)
		card.ability.gold.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_tsun_tsunami_yu)

		if card.ability.gold.sticker >= 8 then
			card.ability.extra.interval = card.ability.extra.interval * 2
		end
	end,
	add_to_deck = function(self, card, from_debuff)
		if card.ability.gold.sticker >= 4 and not from_debuff then
			card:set_edition({ negative = true })
			card:set_eternal(true)
		end
		if card.ability.gold.sticker >= 3 and not from_debuff then
			SMODS.change_free_rerolls(5)
		end
	end,
	remove_from_deck = function(self, card, from_debuff)
		if card.ability.gold.sticker >= 3 and not from_debuff then
			SMODS.change_free_rerolls(-5)
		end
	end,
	calculate = function(self, card, context)
		if context.end_of_round and context.main_eval and card.ability.extra.planets > 0 then
			for i = 1, (card.ability.extra.planets * card.ability.extra.interval) do
				G.E_MANAGER:add_event(Event({
					trigger = 'before',
					delay = 0.0,
					func = (function()
						if RS_pokerhand then
							local _planet = 0
							for k, v in pairs(G.P_CENTER_POOLS.Planet) do
								if v.config.hand_type == RS_pokerhand then
									_planet = v.key
								end
							end
							local card2 = create_card(card_type, G.consumeables, nil, nil, nil, nil, _planet, 'blusl')
							card2:add_to_deck()
							card2:set_edition({ negative = true }, nil)
							G.consumeables:emplace(card2)
							G.GAME.consumeable_buffer = 0
						end
						return true
					end)
				}))
				card:juice_up()
				card_eval_status_text(card, 'extra', nil, nil, nil,
					{ message = localize('k_plus_planet'), colour = G.C.SECONDARY_SET.Planet })
			end
		end

		if context.end_of_round and context.beat_boss then
			card.ability.gold.bossblind = true
		else
			card.ability.gold.bossblind = false
		end
		if not context.blueprint then
			if context.setting_blind and context.blind.boss and card.ability.gold.sticker >= 5 then
				ease_hands_played(2)
				ease_discard(2)
			end
			if context.setting_blind and not context.blind.boss then
				card.ability.gold.bossblind = false
			end
			if context.skip_blind and card.ability.gold.sticker >= 6 then
				card.ability.gold.skips = card.ability.gold.skips + 1
				if card.ability.gold.skips >= card.ability.gold.skipmax then
					card.ability.gold.wild_retriggers = card.ability.gold.wild_retriggers + 1
				end
			end
			if context.joker_main and card.ability.gold.sticker >= 7 then
				return {
					x_mult = card.ability.gold.boss_xmult
				}
			end
			if context.end_of_round and context.main_eval and card.ability.gold.sticker >= 1 then
				if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
					G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
					G.E_MANAGER:add_event(Event({
						trigger = 'before',
						delay = 0.0,
						func = (function()
							SMODS.add_card({ area = G.consumeables, key = "c_lovers" })
							G.GAME.consumeable_buffer = 0
							return true
						end)
					}))
					return {
						message = localize('k_plus_tarot'),
						colour = G.C.SECONDARY_SET.Tarot,
						card = card
					}
				end
			end
			if context.before and card.ability.gold.sticker >= 2 then
				for index, value in ipairs(G.play.cards) do
					if value.config.center == G.P_CENTERS.m_wild then
						value:set_edition(poll_edition("rise", nil, true, true,
							{ "e_foil", "e_polychrome", "e_negative" }))
					end
				end
			end
			if context.end_of_round and context.main_eval and context.beat_boss and card.ability.gold.sticker >= 4 then
				G.jokers.cards[#G.jokers.cards]:set_edition({ negative = true }, true)
			end
			---Handling Wild Card retriggers for Rise's Purple Stake Effect
			if context.repetition and context.cardarea == G.play and card.ability.gold.sticker >= 6 and card.ability.gold.wild_retriggers >= 1 then
				if context.other_card.config.center == G.P_CENTERS.m_wild then
					return {
						repetitions = card.ability.gold.wild_retriggers
					}
				end
			end
			---Blind Disabling
			if context.setting_blind and context.blind.boss and not card.getting_sliced and not context.blueprint then
				---Resetting values
				card.ability.gold.bossblind = true
				card.ability.extra.random = ""
				card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_rise_disable') })
				G.E_MANAGER:add_event(Event({
					func = function()
						G.E_MANAGER:add_event(Event({
							func = function()
								G.GAME.blind:disable()
								play_sound('timpani')
								delay(0.4)
								return true
							end
						}))
						return true
					end
				}))
				---Base Rise effects
				if G.GAME.blind.config.blind.key == "bl_needle" then
					ease_hands_played(card.ability.extra.interval)
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_hand", vars = { card.ability.extra.interval } }
				elseif

					G.GAME.blind.config.blind.key == "bl_psychic" or
					G.GAME.blind.config.blind.key == "bl_final_bell" then
					SMODS.change_discard_limit(card.ability.extra.interval)
					SMODS.change_play_limit(card.ability.extra.interval)
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_psychic", vars = { card.ability.extra.interval } }
				elseif

					G.GAME.blind.config.blind.key == "bl_manacle" or
					G.GAME.blind.config.blind.key == "bl_fish" or
					G.GAME.blind.config.blind.key == "bl_mark" or
					G.GAME.blind.config.blind.key == "bl_wheel" or
					G.GAME.blind.config.blind.key == "bl_house" then
					G.hand:change_size(card.ability.extra.interval)
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_handsize", vars = { card.ability.extra.interval } }
				elseif

					G.GAME.blind.config.blind.key == "bl_tooth" or
					G.GAME.blind.config.blind.key == "bl_ox" then
					card.ability.extra.money = card.ability.extra.money + card.ability.extra.interval * 3
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_money", vars = { card.ability.extra.interval * 3 } }
				elseif

					G.GAME.blind.config.blind.key == "bl_water" or
					G.GAME.blind.config.blind.key == "bl_serpent" or
					G.GAME.blind.config.blind.key == "bl_hook" then
					ease_discard(card.ability.extra.interval)
					G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.interval
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_discard", vars = { card.ability.extra.interval } }
				elseif

					G.GAME.blind.config.blind.key == "bl_final_leaf" or
					G.GAME.blind.config.blind.key == "bl_plant" or
					G.GAME.blind.config.blind.key == "bl_pillar" then
					card.ability.extra.xmult_toggle = card.ability.extra.xmult_toggle +
						card.ability.extra.interval
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_card_xmult", vars = { card.ability.extra.interval * 1.25 } }
				elseif G.GAME.blind.config.blind.key == "bl_wall" then
					ease_ante(-card.ability.extra.interval)
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_minus_ante", vars = { card.ability.extra.interval } }
				elseif G.GAME.blind.config.blind.key == "bl_final_vessel" then
					ease_ante(-card.ability.extra.interval)
					ease_ante_to_win(-card.ability.extra.interval)
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_minus_ante", vars = { card.ability.extra.interval } }
				elseif
					G.GAME.blind.config.blind.key == "bl_flint" or
					G.GAME.blind.config.blind.key == "bl_mouth" or
					G.GAME.blind.config.blind.key == "bl_eye" or
					G.GAME.blind.config.blind.key == "bl_arm" then
					card.ability.extra.planets = (card.ability.extra.planets or 0) + 1
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_pokerhand", vars = { card.ability.extra.interval } }
				elseif
					G.GAME.blind.config.blind.key == "bl_head" then
					card.ability.extra.triggers.Hearts = card.ability.extra.triggers.Hearts + card.ability.extra
						.interval
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_h", vars = { card.ability.extra.interval } }
				elseif
					G.GAME.blind.config.blind.key == "bl_goad" then
					card.ability.extra.triggers.Spades = card.ability.extra.triggers.Spades + card.ability.extra
						.interval
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_s", vars = { card.ability.extra.interval } }
				elseif
					G.GAME.blind.config.blind.key == "bl_window" then
					card.ability.extra.triggers.Diamonds = card.ability.extra.triggers.Diamonds +
						card.ability.extra
						.interval
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_d", vars = { card.ability.extra.interval } }
				elseif
					G.GAME.blind.config.blind.key == "bl_club" then
					card.ability.extra.triggers.Clubs = card.ability.extra.triggers.Clubs +
						card.ability.extra.interval
					card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_c", vars = { card.ability.extra.interval } }
				elseif G.GAME.blind.config.blind.key == "bl_final_heart" then
					card.ability.extra.interval = card.ability.extra.interval * 2
					card.ability.extra.last_buff = localize("k_rise_final_heart")
				elseif G.GAME.blind.config.blind.key == "bl_final_acorn" then
					if #G.jokers.cards > 0 then
						local valid_cards = {}
						for i = 1, #G.jokers.cards do
							if G.jokers.cards[i].ability.name ~= "j_tsun_tsunami_rise" then
								table.insert(valid_cards, G.jokers.cards[i])
							end
						end
						if #valid_cards > 0 then
							G.E_MANAGER:add_event(Event({
								func = function()
									local rand_card = pseudorandom_element(valid_cards, pseudoseed('risette'))
									local new_card = create_card('Joker', G.jokers, nil, nil, nil, nil,
										rand_card.config.center.key, nil)
									new_card:set_edition({ negative = true }, true)
									new_card:add_to_deck()
									G.jokers:emplace(new_card)
									new_card:start_materialize()
									return true
								end
							}))
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {
								message = localize('k_plus_joker'),
								colour = G.C.DARK_EDITION,
							})
							card.ability.extra.last_buff = localize("k_rise_final_acorn")
						else
							card.ability.extra.last_buff = localize("k_rise_failed")
						end
					end
				else
					local randeffect = math.random(1, 8)
					if randeffect == 1 then
						ease_hands_played(card.ability.extra.interval)
						card.ability.extra.random = "Random Buff: "
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_hand", vars = { card.ability.extra.interval } }
					elseif randeffect == 2 then
						card.ability.extra.random = "Random Buff: "
						G.hand:change_size(card.ability.extra.interval)
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_handsize", vars = { card.ability.extra.interval } }
					elseif randeffect == 3 then
						card.ability.extra.random = "Random Buff: "
						ease_discard(card.ability.extra.interval)
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_discard", vars = { card.ability.extra.interval } }
					elseif randeffect == 4 then
						card.ability.extra.random = "Random Buff: "
						SMODS.change_discard_limit(card.ability.extra.interval)
						SMODS.change_play_limit(card.ability.extra.interval)
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_psychic", vars = { card.ability.extra.interval } }
					elseif randeffect == 5 then
						card.ability.extra.random = "Random Buff: "
						ease_ante(-card.ability.extra.interval)
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_minus_ante", vars = { card.ability.extra.interval } }
					elseif randeffect == 6 then
						card.ability.extra.random = "Random Buff: "
						card.ability.extra.money = card.ability.extra.money + (card.ability.extra.interval * 3)
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_money", vars = { card.ability.extra.interval * 3 } }
					elseif randeffect == 7 then
						card.ability.extra.random = "Random Buff: "
						card.ability.extra.xmult_toggle = card.ability.extra.xmult_toggle +
							card.ability.extra.interval
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_card_xmult", vars = { card.ability.extra.interval * 1.25 } }
					elseif randeffect == 8 then
						local _hand, _tally = "High Card", 0
						for k, v in ipairs(G.handlist) do
							if G.GAME.hands[v].visible and G.GAME.hands[v].played > _tally then
								_hand = v
								_tally = G.GAME.hands[v].played
							end
						end
						for i = 1, card.ability.extra.interval do
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
								{ message = localize('k_level_up_ex') })
							update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3 },
								{
									handname = localize(_hand, 'poker_hands'),
									chips = G.GAME.hands[_hand].chips,
									mult = G
										.GAME.hands[_hand].mult,
									level = G.GAME.hands[_hand].level
								})
							level_up_hand(context.blueprint_card or card, _hand, nil, 1)
							update_hand_text({ sound = 'button', volume = 0.7, pitch = 1.1, delay = 0 },
								{ mult = 0, chips = 0, handname = '', level = '' })
						end
						card.ability.extra.random = "Random Buff: "
						card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_pokerhand2", vars = { card.ability.extra.interval } }
					end
				end
			end
			if context.repetition and context.cardarea == G.play then
				if context.other_card.ability_name == "Wild Card" then
					local triggersum =
						card.ability.extra.triggers.Hearts +
						card.ability.extra.triggers.Spades +
						card.ability.extra.triggers.Diamonds +
						card.ability.extra.triggers.Clubs
					return {
						message = localize('k_again_ex'),
						repetitions = triggersum,
						card = card
					}
				elseif context.other_card:is_suit("Hearts") and card.ability.extra.triggers.Hearts >= 1 then
					return {
						message = localize('k_again_ex'),
						repetitions = card.ability.extra.triggers.Hearts,
						card = card
					}
				elseif context.other_card:is_suit("Spades") and card.ability.extra.triggers.Spades >= 1 then
					return {
						message = localize('k_again_ex'),
						repetitions = card.ability.extra.triggers.Spades,
						card = card
					}
				elseif context.other_card:is_suit("Diamonds") and card.ability.extra.triggers.Diamonds >= 1 then
					return {
						message = localize('k_again_ex'),
						repetitions = card.ability.extra.triggers.Diamonds,
						card = card
					}
				elseif context.other_card:is_suit("Clubs") and card.ability.extra.triggers.Clubs >= 1 then
					return {
						message = localize('k_again_ex'),
						repetitions = card.ability.extra.triggers.Clubs,
						card = card
					}
				end
			end
			if context.individual and context.cardarea == G.play and card.ability.extra.xmult_toggle >= 1 then
				return {
					x_mult = card.ability.extra.interval * (1.25 ^ card.ability.extra.xmult_toggle),
					card = card
				}
			end
			if context.after then
				RS_pokerhand = context.scoring_name
			end
		end
	end
}

FusionJokers.fusions:add_fusion("j_splash", nil, false, "j_tsun_tsunami_rise", nil, false,
	"j_tsun_gold_tsunami_rise",
	50)



---chie gold

SMODS.Joker {
	name = "Chie",
	key = "gold_tsunami_chie",
	rarity = "tsun_gold_legendary",
	cost = 50,
	unlocked = true,
	discovered = true,
	blueprint_compat = true,
	eternal_compat = true,
	perishable_compat = false,
	no_aeq = true,
	config = { extra = {
		copies = 2,
		odds = 3,
		odds_gold = 100,
		sticker = 0,
		stickerkey = "none",
	} },
	atlas = "TsunamiGoldLegendary",
	pos = { x = 4, y = 0 },
	soul_pos = { x = 4, y = 1 },
	loc_vars = function(self, info_queue, card)
		local new_numerator2, new_denominator2 = SMODS.get_probability_vars(card, 1, card.ability.extra.odds_gold,
			'tsun_chie')
		for i = 1, 8 do
			info_queue[#info_queue + 1] = {
				key = GC_infolist[i],
				set = 'Other',
				vars = { new_numerator2, new_denominator2 }
			}
		end
		local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'tsun_chie')
		return { vars = { card.ability.extra.copies, new_numerator, new_denominator, card.ability.extra.sticker, card.ability.extra.stickerkey } }
	end,
	set_ability = function(self, card, initial, delay_sprites)
		card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_tsun_tsunami_yosuke)
		card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_tsun_tsunami_yosuke)
	end,
	add_to_deck = function(self, card, from_debuff)
		if card.ability.extra.sticker >= 4 and not from_debuff then
			card:set_edition({ negative = true })
			card:set_eternal(true)
		end
		if card.ability.extra.sticker >= 5 and not from_debuff then
			G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
			card.ability.extra.copies = card.ability.extra.copies + 1
		end
		if card.ability.extra.sticker >= 7 and not from_debuff then
			G.hand:change_size(1)
			G.P_CENTERS.c_chariot.config.max_highlighted = G.P_CENTERS.c_chariot.config.max_highlighted + 1
		end
	end,
	remove_from_deck = function(self, card, from_debuff)
		if card.ability.extra.sticker >= 5 and not from_debuff then
			G.consumeables.config.card_limit = G.consumeables.config.card_limit - 1
		end
		if card.ability.extra.sticker >= 7 and not from_debuff then
			G.hand:change_size(-1)
			G.P_CENTERS.c_chariot.config.max_highlighted = math.max(G.P_CENTERS.c_chariot.config.max_highlighted - 1, 1)
		end
	end,
	calculate = function(self, card, context)
		if context.repetition and (context.cardarea == G.play or context.cardarea == G.hand) then
			if context.other_card.config.center == G.P_CENTERS.m_steel then
				return {
					repetitions = 1
				}
			end
		end
		if context.end_of_round and context.main_eval and context.beat_boss and card.ability.extra.sticker >= 1 then
			if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
				G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
				G.E_MANAGER:add_event(Event({
					trigger = 'before',
					delay = 0.0,
					func = (function()
						SMODS.add_card({ area = G.consumeables, key = "c_chariot" })
						G.GAME.consumeable_buffer = 0
						return true
					end)
				}))
			end
			if card.ability.extra.sticker >= 4 and #G.consumeables.cards >= 1 and (G.consumeables.cards[1].edition == nil or G.consumeables.cards[1].edition.key ~= "e_negative") and card.ability.extra.sticker >= 4 then
				G.E_MANAGER:add_event(Event({
					blockable = true,
					blocking = true,
					func = (function()
						G.consumeables.cards[1]:set_edition({ negative = true }, nil)
						card:juice_up()
						return true
					end)
				}))
			end
		end

		if context.ending_shop then
			---Using the code from Incantation's take_ownership patch for Perkeo if Incantation is loaded
			for i = 1, card.ability.extra.copies do
				if G.consumeables.cards[1] then
					G.E_MANAGER:add_event(Event({
						func = function()
							local card_to_copy
							if card.ability.extra.sticker >= 2 then
								card_to_copy = G.consumeables.cards[1]
							else
								card_to_copy, _ = pseudorandom_element(G.consumeables.cards, 'ez')
							end
							local copied_card = copy_card(card_to_copy)
							copied_card:set_edition("e_negative", true)
							copied_card:add_to_deck()
							G.consumeables:emplace(copied_card)
							return true
						end
					}))
					card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
						{ message = localize('k_duplicated_ex') })
				end
			end
			return { calculated = true }
		end
		if context.end_of_round and context.main_eval and not context.game_over then
			if SMODS.pseudorandom_probability(card, 'god-s_hand', 1, card.ability.extra.odds, 'tsun_chie') and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
				G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
				G.E_MANAGER:add_event(Event({
					blockable = true,
					blocking = true,
					func = (function()
						local s_card
						if SMODS.pseudorandom_probability(card, 'god-s_hand', 1, card.ability.extra.odds_gold, 'tsun_chie') and card.ability.extra.sticker >= 3 then
							s_card = create_card(nil, G.consumeables, nil, nil, nil, nil, 'c_soul', 'sup')
						else
							s_card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'spec')
						end
						s_card:add_to_deck()
						G.consumeables:emplace(s_card)
						G.GAME.consumeable_buffer = 0
						return true
					end)
				}))
			elseif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
				G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
				G.E_MANAGER:add_event(Event({
					trigger = 'before',
					delay = 0.0,
					func = (function()
						local t_card = create_card("Tarot", G.consumeables, nil, nil, nil, nil, nil, 'chie')
						t_card:add_to_deck()
						G.consumeables:emplace(t_card)
						G.GAME.consumeable_buffer = 0
						return true
					end)
				}))
			end
		end
		if context.end_of_round and context.main_eval and context.beat_boss and card.ability.extra.sticker >= 8 then
			if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
				G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
				G.E_MANAGER:add_event(Event({
					trigger = 'before',
					delay = 0.0,
					func = (function()
						SMODS.add_card({ area = G.consumeables, key = "c_tsun_galactic_punt" })
						G.GAME.consumeable_buffer = 0
						return true
					end)
				}))
			end
		end
	end
}

FusionJokers.fusions:register_fusion{
  jokers = {
    { name = "j_splash" },
    { name = "j_tsun_tsunami_chie" },
  }, cost = 50, result_joker = "j_tsun_gold_tsunami_chie"
}


SMODS.Consumable {
	key = 'galactic_punt',
	set = 'Spectral',
	atlas = "TsunamiTarot",
	no_collection = true,
	hidden = true,
	pos = { x = 1, y = 1 },
	config = { max_highlighted = 500 },
	set_card_type_badge = function(self, card, badges)
		badges[1] = create_badge(localize('k_chie_followup'), G.C.EDITION, G.C.WHITE, 1.2)
	end,
	loc_vars = function(self, info_queue, card)
		return { vars = { card.ability.max_highlighted } }
	end,
	use = function(self, card, area, copier)
		G.E_MANAGER:add_event(Event({
			trigger = 'after',
			delay = 0.4,
			func = function()
				play_sound('tarot1')
				card:juice_up(0.3, 0.5)
				return true
			end
		}))
		G.E_MANAGER:add_event(Event({
			trigger = 'after',
			delay = 0.2,
			func = function()
				for index, value in pairs(G.hand.highlighted) do
					value:start_dissolve()
				end
				return true
			end
		}))
		delay(0.3)
	end,
}
