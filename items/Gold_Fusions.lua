---{C:tsun_gold1}{C:tsun_gold2}{C:tsun_gold3}{C:tsun_gold4}{C:tsun_gold5}{C:tsun_gold4}{C:tsun_gold3}{C:tsun_gold2}

if Tsunami_Config.TsunamiLevel2 then
	---Gold Fusion Rarity
	SMODS.Rarity {
		key = "tsun_gold_fusion",
		default_weight = 0,
		badge_colour = HEX("d8b162"),
		pools = { ["Joker"] = false },
		get_weight = function(self, weight, object_type)
			return weight
		end,
	}

	SMODS.Joker {
		key = "gold_splish_splash",
		rarity = "tsun_gold_fusion",
		cost = 15,
		unlocked = true,
		discovered = true,
		blueprint_compat = true,
		eternal_compat = true,
		perishable_compat = true,
		---Cryptid config thingy to disable the Joker from being generated by Ace Equillibrium
		no_aeq = true,
		atlas = "Tsunami",
		pos = { x = 0, y = 17 },
		ability_name = "Gold Splish Splash",
		calculate = function(self, card, context)
			if context.setting_blind then
				local splishcard = create_card("Joker", G.jokers, nil, nil, nil, nil, "j_splash")
				splishcard:add_to_deck()
				splishcard:set_edition({ negative = true })
				G.jokers:emplace(splishcard)
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_tsun_splish_splash", nil, false, "j_splash", nil, false,
		"j_tsun_gold_splish_splash", 15)

	SMODS.Joker {
		key = "gold_reflection",
		rarity = "tsun_gold_fusion",
		cost = 30,
		config = { extra = 1.3, clubs = 0, nonclubs = 0, mult_from_clubs = 1 },
		loc_vars = function(self, info_queue, card)
			return { vars = { card.ability.extra } }
		end,
		unlocked = true,
		discovered = true,
		blueprint_compat = true,
		eternal_compat = true,
		perishable_compat = true,
		no_aeq = true,
		atlas = "Tsunami",
		pos = { x = 1, y = 17 },
		ability_name = "Gold Reflection",
		calculate = function(self, card, context)
			if context.individual and context.cardarea == G.play and not context.blueprint then
				card.ability.mult_from_clubs = 1
				local scoredflag = false
				local increase = 1
				if card_is_splashed(context.other_card) then
					increase = 2
				end
				if not context.other_card.debuff then
					if context.other_card.ability.name == 'Wild Card' then
						card.ability.clubs = card.ability.clubs + increase
						card.ability.nonclubs = card.ability.nonclubs + increase
					elseif context.other_card:is_suit("Clubs") then
						card.ability.clubs = card.ability.clubs + increase
					else
						card.ability.nonclubs = card.ability.nonclubs + increase
					end
				end
				local clubinstances = math.min(card.ability.clubs, card.ability.nonclubs)
				if clubinstances ~= 0 then
					for k = 1, clubinstances, 1 do
						card.ability.mult_from_clubs = card.ability.mult_from_clubs * card.ability.extra
					end
				end
			end
			if context.joker_main then
				card.ability.clubs = 0
				card.ability.nonclubs = 0
				if card.ability.mult_from_clubs > 1 then
					return {
						message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.mult_from_clubs } },
						Xmult_mod = card.ability.mult_from_clubs,
						card = card,
					}
				end
			end
		end
	}
	FusionJokers.fusions:add_fusion("j_tsun_reflection", nil, false, "j_splash", nil, false, "j_tsun_gold_reflection", 20)

	SMODS.Joker {
		key = "gold_cryomancer",
		rarity = "tsun_gold_fusion",
		cost = 15,
		config = { extra = 1 },
		loc_vars = function(self, info_queue, card)
			info_queue[#info_queue + 1] = G.P_CENTERS.j_splash
			return { vars = { card.ability.extra } }
		end,
		unlocked = true,
		discovered = true,
		blueprint_compat = true,
		eternal_compat = true,
		perishable_compat = true,
		---Cryptid config thingy to disable the Joker from being generated by Ace Equillibrium
		no_aeq = true,
		atlas = "Tsunami",
		pos = { x = 3, y = 17 },
		ability_name = "Gold Cryomancer",
		add_to_deck = function(self, card, from_debuff)
			G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra
		end,
		remove_from_deck = function(self, card, from_debuff)
			G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra
		end,
		calculate = function(self, card, context)
			if context.setting_blind then
				if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
					G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
					G.E_MANAGER:add_event(Event({
						blockable = true,
						blocking = true,
						func = function()
							local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
							tarotcard:add_to_deck()
							G.consumeables:emplace(tarotcard)
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
								{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
							G.GAME.consumeable_buffer = G.GAME.consumeable_buffer - 1
							return true
						end
					}))
				end
			end
			if context.end_of_round and not context.bluepirnt and context.main_eval and G.jokers and G.jokers.cards[#G.jokers.cards].config.center.key == "j_splash" then
				if not G.jokers.cards[#G.jokers.cards].ability.eternal then
					local killsplash = G.jokers.cards[#G.jokers.cards]
					if killsplash.edition then
						G.E_MANAGER:add_event(Event({
							blockable = true,
							blocking = true,
							func = function()
								local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
								tarotcard:set_edition({ negative = true }, nil)
								tarotcard:add_to_deck()
								G.consumeables:emplace(tarotcard)
								card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
									{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
								return true
							end
						}))
					end
					killsplash:start_dissolve()
					G.E_MANAGER:add_event(Event({
						blockable = true,
						blocking = true,
						func = function()
							local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
							tarotcard:set_edition({ negative = true }, nil)
							tarotcard:add_to_deck()
							G.consumeables:emplace(tarotcard)
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
								{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
							return true
						end
					}))
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_tsun_cryomancer", nil, false, "j_splash", nil, false,
		"j_tsun_gold_cryomancer", 14)

	SMODS.Joker {
		key = 'gold_holy_water',
		atlas = "Tsunami",
		rarity = "tsun_gold_fusion",
		unlocked = true,
		cost = 20,
		discovered = true,
		config = { mult = 20 },
		pos = { x = 2, y = 17 },
		remove_from_deck = function(self, card, from_debuff)
			G.hand:unhighlight_all()
		end,
		loc_vars = function(self, info_queue, card)
			return { vars = { card.ability.mult } }
		end,
		calculate = function(self, card, context)
			if context.before and next(context.poker_hands['Pair']) then
				return {
					mult = card.ability.mult
				}
			end
		end,
	}

	FusionJokers.fusions:add_fusion('j_tsun_holy_water', nil, nil, 'j_splash', nil, nil, 'j_tsun_gold_holy_water', 18)

	--- Mostly an addition for the high-scoring massively overpowered Balatro Enjoyers.
	GMinfolist = {
		"goldmarie_whitestake",
		"goldmarie_redstake",
		"goldmarie_greenstake",
		"goldmarie_blackstake",
		"goldmarie_bluestake",
		"goldmarie_purplestake",
		"goldmarie_orangestake",
		"goldmarie_goldstake"
	}
	GYo_infolist = {
		"goldyosuke_whitestake",
		"goldyosuke_redstake",
		"goldyosuke_greenstake",
		"goldyosuke_blackstake",
		"goldyosuke_bluestake",
		"goldyosuke_purplestake",
		"goldyosuke_orangestake",
		"goldyosuke_goldstake"
	}

	---Used in a Lovely Patch to change the "Saved by Mr. Bones" text to say "Saved By Gold Marie" if this joker saved you instead
	GMSaved = false
	---Sent to card_is_splashed for extra scored card calculation in Gold Marie's Red Stake effect.
	GMAllExtra = false

	---Sent to the Aeon Tarot Card to activate double-splash spawning.
	AeonDoubleSplash = false

	SMODS.Joker {
		name = "Marie",
		key = "gold_tsunami_marie",
		rarity = "tsun_gold_fusion",
		cost = 50,
		unlocked = true,
		discovered = false,
		blueprint_compat = false,
		eternal_compat = true,
		perishable_compat = false,
		no_aeq = true,

		config = { extra = {
			--- Base effect Xmult
			base = 2,
			--- Key of Splash's Stake Sticker
			stickerkey = "none, you suck",
			sticker = 0,
			retriggers = 1,
			tally = 0,
			basegoldxmult = 1.5,
			goldxmult = 1.5,
		} },
		atlas = "TsunamiGoldLegendary",
		pos = { x = 1, y = 0 },
		soul_pos = { x = 1, y = 1 },
		ability_name = "Gold Marie",
		loc_vars = function(self, info_queue, card)
			for i = 1, 8 do
				info_queue[#info_queue + 1] = {
					key = GMinfolist[i],
					set = 'Other',
				}
			end
			return { vars = { card.ability.extra.base, card.ability.extra.stickerkey, card.ability.extra.sticker } }
		end,
		set_ability = function(self, card, initial, delay_sprites)
			card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_splash)
			card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_splash)
			if card.ability.extra.sticker >= 6 then
				card.ability.extra.base = card.ability.extra.base * 1.5
			end
		end,
		add_to_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 2 then
				GMAllExtra = true
			end
			if card.ability.extra.sticker >= 3 then
				AeonDoubleSplash = true
			end
			if card.ability.extra.sticker >= 4 then
				card:set_edition({ negative = true })
				card:set_eternal(true)
			end
		end,
		remove_from_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 3 then
				AeonDoubleSplash = false
			end
			GMSaved = false
			GMAllExtra = false
		end,
		calculate = function(self, card, context)
			---base marie effect
			if not context.blueprint then
				if context.other_joker then
					if (context.other_joker.config.center.mod and context.other_joker.config.center.mod.id == "Tsunami" and self ~= context.other_joker)
						or ((context.other_joker.config.center.key == "j_splash" or context.other_joker.config.center.key == "j_evo_ripple")) then
						return {
							message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.base } },
							Xmult_mod = card.ability.extra.base,
							card = context.other_joker,
						}
					end
				end
				if context.setting_blind then
					GMSaved = false
				end
				if context.repetition and context.cardarea == G.play and card.ability.extra.sticker >= 2 then
					if card_is_splashed(context.other_card) then
						context.other_card:set_ability(G.P_CENTERS.m_tsun_waterproof)
					end
				end
				if context.end_of_round and context.main_eval and not context.repetition and not context.individual and card.ability.extra.sticker >= 4 then
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" and not value.edition then
							value:set_edition({ negative = true })
						end
					end
				end
				if context.end_of_round and context.main_eval and not context.game_over then
					if card.ability.extra.sticker >= 1 then
						if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
							G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
							G.E_MANAGER:add_event(Event({
								trigger = 'before',
								delay = 0.0,
								func = (function()
									SMODS.add_card({ area = G.consumeables, key = "c_tsun_aeon" })
									G.GAME.consumeable_buffer = 0
									return true
								end)
							}))
							return {
								message = localize('k_plus_tarot'),
								colour = G.C.SECONDARY_SET.Tarot,
								card = card
							}
						end
					end
				end
				if context.individual and context.cardarea == G.play and card.ability.extra.sticker >= 8 then
					card.ability.extra.tally = 0
					card.ability.extra.goldxmult = card.ability.extra.basegoldxmult
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" or (value.config.center.mod and value.config.center.mod.id == "Tsunami") then
							card.ability.extra.tally = card.ability.extra.tally + 1
						end
					end
					card.ability.extra.goldxmult = card.ability.extra.basegoldxmult ^ card.ability.extra.tally
					if card.ability.extra.tally > 0 and card_is_splashed(context.other_card) then
						return {
							x_mult = card.ability.extra.goldxmult,
							card = context.other_card
						}
					end
				end
				if card.ability.extra.sticker >= 5 and context.game_over and not context.repetition and not context.individual and G.GAME.chips / G.GAME.blind.chips >= to_big(0.25) then
					local splashflag = false
					local killflag = true
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" or value.config.center.key == "j_evo_ripple" then
							splashflag = true
						else
							splashflag = false
						end
					end
					if splashflag == true then
						G.E_MANAGER:add_event(Event({
							func = function()
								G.hand_text_area.blind_chips:juice_up()
								G.hand_text_area.game_chips:juice_up()
								play_sound('tarot1')
								return true
							end
						}))
						for index, value in ipairs(G.jokers.cards) do
							if value.config.center.key == "j_splash" or value.config.center.key == "j_evo_ripple" then
								if value.ability.eternal then
									value.ability.eternal = false
								else
									if killflag == true then
										value:start_dissolve()
										killflag = false
									end
								end
							end
						end
						GMSaved = true
						return {
							message = localize('k_saved_ex'),
							saved = true,
							colour = G.C.RED
						}
					end
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_splash", nil, false, "j_tsun_tsunami_marie", nil, false,
		"j_tsun_gold_tsunami_marie", 50)

	SMODS.Joker {
		name = "Yosuke",
		key = "gold_tsunami_yosuke",
		rarity = "tsun_gold_fusion",
		cost = 50,
		unlocked = true,
		discovered = false,
		blueprint_compat = false,
		eternal_compat = true,
		perishable_compat = false,
		no_aeq = true,
		config = { extra = {
			x_mult = 1,
			count = 0,
			countmax = 20,
			gain = 1,
			probcount = 1,
			sticker = 0,
			stickerkey = "none",
		} },
		atlas = "TsunamiGoldLegendary",
		pos = { x = 2, y = 0 },
		soul_pos = { x = 2, y = 1 },
		loc_vars = function(self, info_queue, card)
			for i = 1, 8 do
				info_queue[#info_queue + 1] = {
					key = GYo_infolist[i],
					set = 'Other',
				}
			end
			return { vars = { card.ability.extra.x_mult, card.ability.extra.count, card.ability.extra.countmax, card.ability.extra.gain, card.ability.extra.sticker, card.ability.extra.stickerkey } }
		end,
		set_ability = function(self, card, initial, delay_sprites)
			card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_tsun_tsunami_yosuke)
			card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_tsun_tsunami_yosuke)
			if card.ability.extra.sticker >= 6 then
				card.ability.extra.x_mult = card.ability.extra.x_mult * 2
				card.ability.extra.gain = card.ability.extra.gain * 2
			end
		end,
		add_to_deck = function(self, card, from_debuff)
			if card.ability.extra.x_mult == 1 and card.ability.x_mult then
				card.ability.extra.x_mult = card.ability.x_mult
				card.ability.x_mult = 1
			end
			if card.ability.extra.sticker >= 4 then
				card:set_edition({ negative = true })
				card:set_eternal(true)
			end
			if card.ability.extra.sticker >= 3 then
				for k, v in pairs(G.GAME.probabilities) do
					G.GAME.probabilities[k] = v + 1
				end
				card.ability.extra.probcount = math.max(card.ability.extra.probcount + 1, 0)
			end
			if card.ability.extra.sticker >= 4 then
				for k, v in pairs(G.GAME.probabilities) do
					G.GAME.probabilities[k] = v * 2
				end
				card.ability.extra.probcount = math.max(card.ability.extra.probcount * 2, 0)
			end
			if card.ability.extra.sticker >= 5 then
				G.GAME.modifiers.extra_boosters = (G.GAME.modifiers.extra_boosters or 0) + 1
				if G.shop_booster and G.shop_booster.cards then
					G.shop_booster.config.card_limit = G.GAME.starting_params.boosters_in_shop +
						(G.GAME.modifiers.extra_boosters or 0)
					for i = #G.shop_booster.cards + 1, G.shop_booster.config.card_limit do
						G.GAME.current_round.used_packs[i] = get_pack('shop_pack').key
						local card = Card(G.shop_booster.T.x + G.shop_booster.T.w / 2,
							G.shop_booster.T.y, G.CARD_W * 1.27, G.CARD_H * 1.27, G.P_CARDS.empty,
							G.P_CENTERS[G.GAME.current_round.used_packs[i]],
							{ bypass_discovery_center = true, bypass_discovery_ui = true })
						create_shop_card_ui(card, 'Booster', G.shop_booster)
						card.ability.booster_pos = i
						G.shop_booster:emplace(card)
					end
				end
			end
			if card.ability.extra.sticker >= 6 then
				change_shop_size(1)
			end
		end,
		remove_from_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 3 and card.ability.extra.probcount > 1 then
				for k, v in pairs(G.GAME.probabilities) do
					G.GAME.probabilities[k] = v - 1
				end
				card.ability.extra.probcount = math.floor(math.max(card.ability.extra.probcount - 1, 0))
			end
			if card.ability.extra.sticker >= 4 and card.ability.extra.probcount > 1 then
				for k, v in pairs(G.GAME.probabilities) do
					G.GAME.probabilities[k] = v / 2
				end
				card.ability.extra.probcount = math.floor(math.max(card.ability.extra.probcount / 2, 0))
			end
			if card.ability.extra.sticker >= 5 then
				G.GAME.modifiers.extra_boosters = math.max(G.GAME.modifiers.extra_boosters - 1, 0)
			end
			if card.ability.extra.sticker >= 6 then
				change_shop_size(-1)
			end
		end,
		calculate = function(self, card, context)
			if not context.blueprint then
				---base Yosuke effect
				if context.before then
					for index, value in ipairs(G.play.cards) do
						if card_is_splashed(value) == true then
							card.ability.extra.count = card.ability.extra.count +
								(1 * math.max(0, G.GAME.current_round.discards_left))
							if card.ability.extra.count >= card.ability.extra.countmax then
								card_eval_status_text(card, 'extra', nil, nil, nil,
									{ message = localize('k_upgrade_ex'), colour = G.C.ATTENTION })
								card.ability.extra.x_mult = card.ability.extra.x_mult + 1
								card.ability.extra.count = card.ability.extra.count - card.ability.extra.countmax
							end
						end
					end
				end
				if context.individual and context.cardarea == G.play then
					if card.ability.extra.count >= card.ability.extra.countmax then
						card_eval_status_text(card, 'extra', nil, nil, nil,
							{ message = localize('k_upgrade_ex'), colour = G.C.ATTENTION })
						card.ability.extra.x_mult = card.ability.extra.x_mult + 1
						card.ability.extra.count = card.ability.extra.count - card.ability.extra.countmax
					end
				end
				if context.joker_main then
					return {
						message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
						Xmult_mod = card.ability.extra.x_mult,
					}
				end
				if context.end_of_round and context.main_eval and not context.game_over then
					if card.ability.extra.sticker >= 2 then
						card.ability.extra.count = card.ability.extra.count +
							math.max(0, G.GAME.current_round.discards_left)
					end
					if card.ability.extra.sticker >= 1 then
						if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
							G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
							G.E_MANAGER:add_event(Event({
								trigger = 'before',
								delay = 0.0,
								func = (function()
									SMODS.add_card({ area = G.consumeables, key = "c_magician" })
									G.GAME.consumeable_buffer = 0
									return true
								end)
							}))
							return {
								message = localize('k_plus_tarot'),
								colour = G.C.SECONDARY_SET.Tarot,
								card = card
							}
						end
					end
				end
				if G.GAME.shop and card.ability.extra.sticker >= 5 then
					if G.shop_booster and G.shop_booster.cards then
						for _, booster in ipairs(G.shop_booster.cards) do
							if not booster.yosuke_hit then
								booster.ability.extra = (booster.ability.extra or 1) + 1
								booster.ability.choose = (booster.ability.choose or 1) + 1
								booster.yosuke_hit = true
							end
						end
					end
				end
				if context.buying_card and card.ability.extra.sticker >= 7 then
					if not context.card.edition then
						context.card:set_edition(poll_edition("yosuke", nil, true, true,
							{ "e_foil", "e_holo", "e_polychrome", "e_negative" }))
					end
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_splash", nil, false, "j_tsun_tsunami_yosuke", "x_mult", true,
		"j_tsun_gold_tsunami_yosuke", 50)


	--- this end is for the gold jokers config check DO NOT REMOVE IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
end
