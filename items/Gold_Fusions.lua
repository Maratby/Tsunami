---{C:tsun_gold1}{C:tsun_gold2}{C:tsun_gold3}{C:tsun_gold4}{C:tsun_gold5}{C:tsun_gold4}{C:tsun_gold3}{C:tsun_gold2}

if Tsunami_Config.TsunamiLevel2 then
	---Gold Fusion Rarity
	SMODS.Rarity {
		key = "tsun_gold_fusion",
		default_weight = 0,
		badge_colour = HEX("d8b162"),
		pools = { ["Joker"] = false },
		get_weight = function(self, weight, object_type)
			return weight
		end,
	}

	SMODS.Joker {
		key = "gold_splish_splash",
		rarity = "tsun_gold_fusion",
		cost = 15,
		unlocked = true,
		discovered = true,
		blueprint_compat = true,
		eternal_compat = true,
		perishable_compat = true,
		---Cryptid config thingy to disable the Joker from being generated by Ace Equillibrium
		no_aeq = true,
		atlas = "Tsunami",
		pos = { x = 0, y = 17 },
		ability_name = "Gold Splish Splash",
		calculate = function(self, card, context)
			if context.setting_blind then
				local splishcard = create_card("Joker", G.jokers, nil, nil, nil, nil, "j_splash")
				splishcard:add_to_deck()
				splishcard:set_edition({ negative = true })
				G.jokers:emplace(splishcard)
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_tsun_splish_splash", nil, false, "j_splash", nil, false,
		"j_tsun_gold_splish_splash", 15)

	SMODS.Joker {
		key = "gold_reflection",
		rarity = "tsun_gold_fusion",
		cost = 30,
		config = { extra = 1.3, clubs = 0, nonclubs = 0, mult_from_clubs = 1 },
		loc_vars = function(self, info_queue, card)
			return { vars = { card.ability.extra } }
		end,
		unlocked = true,
		discovered = true,
		blueprint_compat = true,
		eternal_compat = true,
		perishable_compat = true,
		no_aeq = true,
		atlas = "Tsunami",
		pos = { x = 1, y = 17 },
		ability_name = "Gold Reflection",
		calculate = function(self, card, context)
			if context.individual and context.cardarea == G.play and not context.blueprint then
				card.ability.mult_from_clubs = 1
				local scoredflag = false
				local increase = 1
				if card_is_splashed(context.other_card) then
					increase = 2
				end
				if not context.other_card.debuff then
					if context.other_card.ability.name == 'Wild Card' then
						card.ability.clubs = card.ability.clubs + increase
						card.ability.nonclubs = card.ability.nonclubs + increase
					elseif context.other_card:is_suit("Clubs") then
						card.ability.clubs = card.ability.clubs + increase
					else
						card.ability.nonclubs = card.ability.nonclubs + increase
					end
				end
				local clubinstances = math.min(card.ability.clubs, card.ability.nonclubs)
				if clubinstances ~= 0 then
					for k = 1, clubinstances, 1 do
						card.ability.mult_from_clubs = card.ability.mult_from_clubs * card.ability.extra
					end
				end
			end
			if context.joker_main then
				card.ability.clubs = 0
				card.ability.nonclubs = 0
				if card.ability.mult_from_clubs > 1 then
					return {
						message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.mult_from_clubs } },
						Xmult_mod = card.ability.mult_from_clubs,
						card = card,
					}
				end
			end
		end
	}
	FusionJokers.fusions:add_fusion("j_tsun_reflection", nil, false, "j_splash", nil, false, "j_tsun_gold_reflection", 20)

	SMODS.Joker {
		key = "gold_cryomancer",
		rarity = "tsun_gold_fusion",
		cost = 15,
		config = { extra = 1 },
		loc_vars = function(self, info_queue, card)
			info_queue[#info_queue + 1] = G.P_CENTERS.j_splash
			return { vars = { card.ability.extra } }
		end,
		unlocked = true,
		discovered = true,
		blueprint_compat = true,
		eternal_compat = true,
		perishable_compat = true,
		---Cryptid config thingy to disable the Joker from being generated by Ace Equillibrium
		no_aeq = true,
		atlas = "Tsunami",
		pos = { x = 3, y = 17 },
		ability_name = "Gold Cryomancer",
		add_to_deck = function(self, card, from_debuff)
			G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra
		end,
		remove_from_deck = function(self, card, from_debuff)
			G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra
		end,
		calculate = function(self, card, context)
			if context.setting_blind then
				if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
					G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
					G.E_MANAGER:add_event(Event({
						blockable = true,
						blocking = true,
						func = function()
							local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
							tarotcard:add_to_deck()
							G.consumeables:emplace(tarotcard)
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
								{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
							G.GAME.consumeable_buffer = G.GAME.consumeable_buffer - 1
							return true
						end
					}))
				end
			end
			if context.end_of_round and not context.bluepirnt and context.main_eval and G.jokers and G.jokers.cards[#G.jokers.cards].config.center.key == "j_splash" then
				if not G.jokers.cards[#G.jokers.cards].ability.eternal then
					local killsplash = G.jokers.cards[#G.jokers.cards]
					if killsplash.edition then
						G.E_MANAGER:add_event(Event({
							blockable = true,
							blocking = true,
							func = function()
								local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
								tarotcard:set_edition({ negative = true }, nil)
								tarotcard:add_to_deck()
								G.consumeables:emplace(tarotcard)
								card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
									{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
								return true
							end
						}))
					end
					killsplash:start_dissolve()
					G.E_MANAGER:add_event(Event({
						blockable = true,
						blocking = true,
						func = function()
							local tarotcard = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'tar')
							tarotcard:set_edition({ negative = true }, nil)
							tarotcard:add_to_deck()
							G.consumeables:emplace(tarotcard)
							card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
								{ message = localize('k_plus_tarot'), colour = G.C.PURPLE })
							return true
						end
					}))
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_tsun_cryomancer", nil, false, "j_splash", nil, false,
		"j_tsun_gold_cryomancer", 14)

	SMODS.Joker {
		key = 'gold_holy_water',
		atlas = "Tsunami",
		rarity = "tsun_gold_fusion",
		unlocked = true,
		cost = 20,
		discovered = true,
		config = { mult = 20 },
		pos = { x = 2, y = 17 },
		remove_from_deck = function(self, card, from_debuff)
			G.hand:unhighlight_all()
		end,
		loc_vars = function(self, info_queue, card)
			return { vars = { card.ability.mult } }
		end,
		calculate = function(self, card, context)
			if context.joker_main and next(context.poker_hands['Pair']) then
				return {
					mult = card.ability.mult
				}
			end
		end,
	}

	FusionJokers.fusions:add_fusion('j_tsun_holy_water', nil, nil, 'j_splash', nil, nil, 'j_tsun_gold_holy_water', 10)

	--- Mostly an addition for the high-scoring massively overpowered Balatro Enjoyers.
	GMinfolist = {
		"goldmarie_whitestake",
		"goldmarie_redstake",
		"goldmarie_greenstake",
		"goldmarie_blackstake",
		"goldmarie_bluestake",
		"goldmarie_purplestake",
		"goldmarie_orangestake",
		"goldmarie_goldstake"
	}
	GYo_infolist = {
		"goldyosuke_whitestake",
		"goldyosuke_redstake",
		"goldyosuke_greenstake",
		"goldyosuke_blackstake",
		"goldyosuke_bluestake",
		"goldyosuke_purplestake",
		"goldyosuke_orangestake",
		"goldyosuke_goldstake"
	}
	GR_infolist = {
		"goldrise_whitestake",
		"goldrise_redstake",
		"goldrise_greenstake",
		"goldrise_blackstake",
		"goldrise_bluestake",
		"goldrise_purplestake",
		"goldrise_orangestake",
		"goldrise_goldstake"
	}
	---Sent to card_is_splashed for extra scored card calculation in Gold Marie's Red Stake effect.
	GMAllExtra = false
	---Sent to the Aeon Tarot Card to activate double-splash spawning.
	AeonDoubleSplash = false

	SMODS.Joker {
		name = "Marie",
		key = "gold_tsunami_marie",
		rarity = "tsun_gold_fusion",
		cost = 50,
		unlocked = true,
		discovered = false,
		blueprint_compat = false,
		eternal_compat = true,
		perishable_compat = false,
		no_aeq = true,

		config = { extra = {
			--- Base effect Xmult
			base = 2,
			--- Key of Splash's Stake Sticker
			stickerkey = "none, you suck",
			sticker = 0,
			retriggers = 1,
			tally = 0,
			basegoldxmult = 1.5,
			goldxmult = 1.5,
		} },
		atlas = "TsunamiGoldLegendary",
		pos = { x = 1, y = 0 },
		soul_pos = { x = 1, y = 1 },
		ability_name = "Gold Marie",
		loc_vars = function(self, info_queue, card)
			for i = 1, 8 do
				info_queue[#info_queue + 1] = {
					key = GMinfolist[i],
					set = 'Other',
				}
			end
			return { vars = { card.ability.extra.base, card.ability.extra.stickerkey, card.ability.extra.sticker } }
		end,
		set_ability = function(self, card, initial, delay_sprites)
			card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_splash)
			card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_splash)
			if card.ability.extra.sticker >= 6 then
				card.ability.extra.base = card.ability.extra.base * 1.5
			end
		end,
		add_to_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 2 then
				GMAllExtra = true
			end
			if card.ability.extra.sticker >= 3 then
				AeonDoubleSplash = true
			end
			if card.ability.extra.sticker >= 4 and not from_debuff then
				card:set_edition({ negative = true })
				card:set_eternal(true)
			end
		end,
		remove_from_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 3 then
				AeonDoubleSplash = false
			end
			GMAllExtra = false
		end,
		calculate = function(self, card, context)
			---lazy updating values so they get reapplied when exiting and re-entering a run
			if card.ability.extra.sticker >= 2 then
				GMAllExtra = true
			end
			if card.ability.extra.sticker >= 3 then
				AeonDoubleSplash = true
			end

			---base marie effect
			if not context.blueprint then
				if context.other_joker then
					if (context.other_joker.config.center.mod and context.other_joker.config.center.mod.id == "Tsunami" and self ~= context.other_joker)
						or ((context.other_joker.config.center.key == "j_splash" or context.other_joker.config.center.key == "j_evo_ripple")) then
						return {
							message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.base } },
							Xmult_mod = card.ability.extra.base,
							card = context.other_joker,
						}
					end
				end
				if context.repetition and context.cardarea == G.play and card.ability.extra.sticker >= 2 then
					if card_is_splashed(context.other_card) then
						context.other_card:set_ability(G.P_CENTERS.m_tsun_waterproof)
					end
				end
				if context.end_of_round and context.main_eval and not context.repetition and not context.individual and card.ability.extra.sticker >= 4 then
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" and not value.edition then
							value:set_edition({ negative = true })
						end
					end
				end
				if context.end_of_round and context.main_eval and not context.game_over then
					if card.ability.extra.sticker >= 1 then
						if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
							G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
							G.E_MANAGER:add_event(Event({
								trigger = 'before',
								delay = 0.0,
								func = (function()
									SMODS.add_card({ area = G.consumeables, key = "c_tsun_aeon" })
									G.GAME.consumeable_buffer = 0
									return true
								end)
							}))
							return {
								message = localize('k_plus_tarot'),
								colour = G.C.SECONDARY_SET.Tarot,
								card = card
							}
						end
					end
				end
				if context.individual and context.cardarea == G.play and card.ability.extra.sticker >= 8 then
					card.ability.extra.tally = 0
					card.ability.extra.goldxmult = card.ability.extra.basegoldxmult
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" or (value.config.center.mod and value.config.center.mod.id == "Tsunami") then
							card.ability.extra.tally = card.ability.extra.tally + 1
						end
					end
					card.ability.extra.goldxmult = card.ability.extra.basegoldxmult ^ card.ability.extra.tally
					if card.ability.extra.tally > 0 and card_is_splashed(context.other_card) then
						return {
							x_mult = card.ability.extra.goldxmult,
							card = context.other_card
						}
					end
				end
				if card.ability.extra.sticker >= 5 and context.game_over and not context.repetition and not context.individual and G.GAME.chips / G.GAME.blind.chips >= to_big(0.25) then
					local splashflag = false
					local killflag = true
					for index, value in ipairs(G.jokers.cards) do
						if value.config.center.key == "j_splash" or value.config.center.key == "j_evo_ripple" then
							splashflag = true
						else
							splashflag = false
						end
					end
					if splashflag == true then
						G.E_MANAGER:add_event(Event({
							func = function()
								G.hand_text_area.blind_chips:juice_up()
								G.hand_text_area.game_chips:juice_up()
								play_sound('tarot1')
								return true
							end
						}))
						for index, value in ipairs(G.jokers.cards) do
							if value.config.center.key == "j_splash" or value.config.center.key == "j_evo_ripple" then
								if value.ability.eternal then
									value.ability.eternal = false
								else
									if killflag == true then
										value:start_dissolve()
										killflag = false
									end
								end
							end
						end
						return {
							message = localize('k_saved_ex'),
							saved = "k_mariesave",
							colour = G.C.RED
						}
					end
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_splash", nil, false, "j_tsun_tsunami_marie", nil, false,
		"j_tsun_gold_tsunami_marie", 50)

	SMODS.Joker {
		name = "Yosuke",
		key = "gold_tsunami_yosuke",
		rarity = "tsun_gold_fusion",
		cost = 50,
		unlocked = true,
		discovered = false,
		blueprint_compat = false,
		eternal_compat = true,
		perishable_compat = false,
		no_aeq = true,
		config = { extra = {
			x_mult = 1,
			count = 0,
			countmax = 20,
			gain = 1,
			---Probcount value no longer needed due to new probability changes
			sticker = 0,
			stickerkey = "none",
		} },
		atlas = "TsunamiGoldLegendary",
		pos = { x = 2, y = 0 },
		soul_pos = { x = 2, y = 1 },
		loc_vars = function(self, info_queue, card)
			for i = 1, 8 do
				info_queue[#info_queue + 1] = {
					key = GYo_infolist[i],
					set = 'Other',
				}
			end
			return { vars = { card.ability.extra.x_mult, card.ability.extra.count, card.ability.extra.countmax, card.ability.extra.gain, card.ability.extra.sticker, card.ability.extra.stickerkey } }
		end,
		set_ability = function(self, card, initial, delay_sprites)
			card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_tsun_tsunami_chie)
			card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_tsun_tsunami_chie)
			if card.ability.extra.sticker >= 6 then
				card.ability.extra.x_mult = card.ability.extra.x_mult * 2
				card.ability.extra.gain = card.ability.extra.gain * 2
			end
		end,
		add_to_deck = function(self, card, from_debuff)
			if card.ability.extra.x_mult == 1 and card.ability.x_mult then
				card.ability.extra.x_mult = card.ability.x_mult
				card.ability.x_mult = 1
			end
			if card.ability.extra.sticker >= 4 and not from_debuff then
				card:set_edition({ negative = true })
				card:set_eternal(true)
			end
			if card.ability.extra.sticker >= 5 then
				G.GAME.modifiers.extra_boosters = (G.GAME.modifiers.extra_boosters or 0) + 1
				if G.shop_booster and G.shop_booster.cards then
					G.shop_booster.config.card_limit = G.GAME.starting_params.boosters_in_shop +
						(G.GAME.modifiers.extra_boosters or 0)
					for i = #G.shop_booster.cards + 1, G.shop_booster.config.card_limit do
						G.GAME.current_round.used_packs[i] = get_pack('shop_pack').key
						local card = Card(G.shop_booster.T.x + G.shop_booster.T.w / 2,
							G.shop_booster.T.y, G.CARD_W * 1.27, G.CARD_H * 1.27, G.P_CARDS.empty,
							G.P_CENTERS[G.GAME.current_round.used_packs[i]],
							{ bypass_discovery_center = true, bypass_discovery_ui = true })
						create_shop_card_ui(card, 'Booster', G.shop_booster)
						card.ability.booster_pos = i
						G.shop_booster:emplace(card)
					end
				end
			end
			if card.ability.extra.sticker >= 6 then
				change_shop_size(1)
			end
		end,
		remove_from_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 5 then
				G.GAME.modifiers.extra_boosters = math.max(G.GAME.modifiers.extra_boosters - 1, 0)
			end
			if card.ability.extra.sticker >= 6 then
				change_shop_size(-1)
			end
		end,
		calculate = function(self, card, context)
			---New probability stuff
			if context.mod_probability and not context.blueprint then
				if card.ability.extra.sticker <= 4 then
					return {
						numerator = (context.numerator + 1) * 2
					}
				elseif card.ability.extra.sticker <= 3 then
					return {
						numerator = context.numerator + 1
					}
				end
			end

			if not context.blueprint then
				---base Yosuke effect
				if context.before then
					for index, value in ipairs(G.play.cards) do
						if card_is_splashed(value) == true then
							card.ability.extra.count = card.ability.extra.count +
								(1 * math.max(0, G.GAME.current_round.discards_left))
							if card.ability.extra.count >= card.ability.extra.countmax then
								card_eval_status_text(card, 'extra', nil, nil, nil,
									{ message = localize('k_upgrade_ex'), colour = G.C.ATTENTION })
								card.ability.extra.x_mult = card.ability.extra.x_mult + 1
								card.ability.extra.count = card.ability.extra.count - card.ability.extra.countmax
							end
						end
					end
				end
				if context.individual and context.cardarea == G.play then
					if card.ability.extra.count >= card.ability.extra.countmax then
						card_eval_status_text(card, 'extra', nil, nil, nil,
							{ message = localize('k_upgrade_ex'), colour = G.C.ATTENTION })
						card.ability.extra.x_mult = card.ability.extra.x_mult + 1
						card.ability.extra.count = card.ability.extra.count - card.ability.extra.countmax
					end
				end
				if context.joker_main then
					return {
						message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
						Xmult_mod = card.ability.extra.x_mult,
					}
				end
				if context.end_of_round and context.main_eval and not context.game_over then
					if card.ability.extra.sticker >= 2 then
						card.ability.extra.count = card.ability.extra.count +
							math.max(0, G.GAME.current_round.discards_left)
					end
					if card.ability.extra.sticker >= 1 then
						if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
							G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
							G.E_MANAGER:add_event(Event({
								trigger = 'before',
								delay = 0.0,
								func = (function()
									SMODS.add_card({ area = G.consumeables, key = "c_magician" })
									G.GAME.consumeable_buffer = 0
									return true
								end)
							}))
							return {
								message = localize('k_plus_tarot'),
								colour = G.C.SECONDARY_SET.Tarot,
								card = card
							}
						end
					end
				end
				if G.GAME.shop and card.ability.extra.sticker >= 5 then
					if G.shop_booster and G.shop_booster.cards then
						for _, booster in ipairs(G.shop_booster.cards) do
							if not booster.yosuke_hit then
								booster.ability.extra = (booster.ability.extra or 1) + 1
								booster.ability.choose = (booster.ability.choose or 1) + 1
								booster.yosuke_hit = true
							end
						end
					end
				end
				if context.buying_card and card.ability.extra.sticker >= 7 then
					if not context.card.edition then
						context.card:set_edition(poll_edition("yosuke", nil, true, true,
							{ "e_foil", "e_holo", "e_polychrome", "e_negative" }))
					end
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_splash", nil, false, "j_tsun_tsunami_yosuke", "x_mult", true,
		"j_tsun_gold_tsunami_yosuke", 50)



	--- Gold rise...
	--- Ffffucking hell this is gonna be a nightmare

	local rs_pokerhand
	SMODS.Joker {
		key = "gold_tsunami_rise",
		rarity = "tsun_gold_fusion",
		cost = 50,
		unlocked = true,
		discovered = true,
		blueprint_compat = false,
		eternal_compat = true,
		perishable_compat = false,
		---Cryptid config things
		immutable = true,
		no_aeq = true,

		config = { extra = {
			---Base Rise Values
			last_buff = "None",
			random = "",
			money = 0,
			interval = 1,
			planets = 0,
			triggers = { Hearts = 0, Spades = 0, Diamonds = 0, Clubs = 0 },
			xmult_toggle = 0,
			---Gold Fusion Values
			sticker = 0,
			stickerkey = "None! You can do this!",
			boss_xmult = 10,
			odds = 4,
			handbonus = 2,
			wild_retriggers = 0,
			skips = 0,
			skipmax = 4,
			bossblind = false,
		} },

		atlas = "TsunamiGoldLegendary",
		pos = { x = 3, y = 0 },
		soul_pos = { x = 3, y = 1 },
		loc_vars = function(self, info_queue, card)
			local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds,
				'tsun_gold_rise')
			for i = 1, 8 do
				info_queue[#info_queue + 1] = {
					key = GR_infolist[i],
					set = 'Other',
					vars = { card.ability.extra.wild_retriggers, card.ability.extra.skips, card.ability.extra.skipmax, new_numerator, new_denominator }
				}
			end
			return { vars = { card.ability.extra.last_buff, card.ability.extra.random, card.ability.extra.stickerkey, card.ability.extra.sticker, card.ability.extra.base_xmult } }
		end,
		calc_dollar_bonus = function(self, card)
			local bonus = card.ability.extra.money * G.GAME.round_resets.ante
			if bonus > 0 then
				return G.GAME.blind.boss and bonus or nil
			end
		end,
		set_ability = function(self, card, initial, delay_sprites)
			card.ability.extra.sticker = sticker_inquisition(G.P_CENTERS.j_tsun_tsunami_yu)
			card.ability.extra.stickerkey = get_joker_win_sticker(G.P_CENTERS.j_tsun_tsunami_yu)
		end,
		add_to_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 4 and not from_debuff then
				card:set_edition({ negative = true })
				card:set_eternal(true)
			end
			if card.ability.extra.sticker >= 3 and not from_debuff then
				SMODS.change_free_rerolls(5)
			end
		end,
		remove_from_deck = function(self, card, from_debuff)
			if card.ability.extra.sticker >= 3 and not from_debuff then
				SMODS.change_free_rerolls(-5)
			end
		end,
		calculate = function(self, card, context)
			if context.end_of_round and context.beat_boss then
				card.ability.extra.bossblind = true
			else
				card.ability.extra.bossblind = false
			end
			if not context.blueprint then
				if context.setting_blind and context.blind.boss and card.ability.extra.sticker >= 5 then
					ease_hands_played(2)
					ease_discard(2)
				end
				if context.setting_blind and not context.blind.boss then
					card.ability.extra.bossblind = false
				end
				if context.skip_blind and card.ability.extra.sticker >= 6 then
					card.ability.extra.skips = card.ability.extra.skips + 1
					if card.ability.extra.skips >= card.ability.extra.skipmax then
						card.ability.extra.wild_retriggers = card.ability.extra.wild_retriggers + 1
					end
				end
				if context.joker_main and card.ability.extra.sticker >= 7 then
					return {
						x_mult = card.ability.extra.boss_xmult
					}
				end
				if context.end_of_round and context.main_eval and card.ability.extra.sticker >= 1 then
					if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
						G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
						G.E_MANAGER:add_event(Event({
							trigger = 'before',
							delay = 0.0,
							func = (function()
								SMODS.add_card({ area = G.consumeables, key = "c_lovers" })
								G.GAME.consumeable_buffer = 0
								return true
							end)
						}))
						return {
							message = localize('k_plus_tarot'),
							colour = G.C.SECONDARY_SET.Tarot,
							card = card
						}
					end
				end
				if context.before and card.ability.extra.sticker >= 2 then
					for index, value in ipairs(G.play.cards) do
						if value.config.center == G.P_CENTERS.m_wild then
							value:set_edition(poll_edition("rise", nil, true, true,
								{ "e_foil", "e_polychrome", "e_negative" }))
						end
					end
				end
				if context.end_of_round and context.main_eval and card.ability.extra.sticker >= 4 then
					G.jokers.cards[#G.jokers.cards]:set_edition({ negative = true }, true)
				end
				---Handling Wild Card retriggers for Rise's Purple Stake Effect
				if context.repetition and context.cardarea == G.play and card.ability.extra.sticker >= 6 and card.ability.extra.wild_retriggers >= 1 then
					if context.other_card.config.center == G.P_CENTERS.m_wild then
						return {
							repetitions = card.ability.extra.wild_retriggers
						}
					end
				end
				---Blind Disabling
				if context.setting_blind and context.blind.boss and not card.getting_sliced and not context.blueprint then
					---Resetting values
					card.ability.extra.bossblind = true
					card.ability.extra.random = ""
					card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_rise_disable') })
					G.E_MANAGER:add_event(Event({
						func = function()
							G.E_MANAGER:add_event(Event({
								func = function()
									G.GAME.blind:disable()
									play_sound('timpani')
									delay(0.4)
									return true
								end
							}))
							return true
						end
					}))


					if card.ability.extra.sticker >= 9 then --- REMEMBER TO CHANGE THIS TO 8 WHEN THE GOLD STAKE EFFECT IS READY

					else
						---Base Rise effects
						if G.GAME.blind.config.blind.key == "bl_needle" then
							ease_hands_played(card.ability.extra.interval)
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_hand", vars = { card.ability.extra.interval } }
						elseif

							G.GAME.blind.config.blind.key == "bl_psychic" or
							G.GAME.blind.config.blind.key == "bl_final_bell" then
							SMODS.change_discard_limit(card.ability.extra.interval)
							SMODS.change_play_limit(card.ability.extra.interval)
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_psychic", vars = { card.ability.extra.interval } }
						elseif

							G.GAME.blind.config.blind.key == "bl_manacle" or
							G.GAME.blind.config.blind.key == "bl_fish" or
							G.GAME.blind.config.blind.key == "bl_mark" or
							G.GAME.blind.config.blind.key == "bl_wheel" or
							G.GAME.blind.config.blind.key == "bl_house" then
							G.hand:change_size(card.ability.extra.interval)
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_handsize", vars = { card.ability.extra.interval } }
						elseif

							G.GAME.blind.config.blind.key == "bl_tooth" or
							G.GAME.blind.config.blind.key == "bl_ox" then
							card.ability.extra.money = card.ability.extra.money + card.ability.extra.interval * 3
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_money", vars = { card.ability.extra.interval * 3 } }
						elseif

							G.GAME.blind.config.blind.key == "bl_water" or
							G.GAME.blind.config.blind.key == "bl_serpent" or
							G.GAME.blind.config.blind.key == "bl_hook" then
							ease_discard(card.ability.extra.interval)
							G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.interval
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_discard", vars = { card.ability.extra.interval } }
						elseif

							G.GAME.blind.config.blind.key == "bl_final_leaf" or
							G.GAME.blind.config.blind.key == "bl_plant" or
							G.GAME.blind.config.blind.key == "bl_pillar" then
							card.ability.extra.xmult_toggle = card.ability.extra.xmult_toggle +
								card.ability.extra.interval
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_card_xmult", vars = { card.ability.extra.interval * 1.25 } }
						elseif G.GAME.blind.config.blind.key == "bl_wall" then
							ease_ante(-card.ability.extra.interval)
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_minus_ante", vars = { card.ability.extra.interval } }
						elseif G.GAME.blind.config.blind.key == "bl_final_vessel" then
							ease_ante(-card.ability.extra.interval)
							ease_ante_to_win(-card.ability.extra.interval)
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_minus_ante", vars = { card.ability.extra.interval } }
						elseif
							G.GAME.blind.config.blind.key == "bl_flint" or
							G.GAME.blind.config.blind.key == "bl_mouth" or
							G.GAME.blind.config.blind.key == "bl_eye" or
							G.GAME.blind.config.blind.key == "bl_arm" then
							card.ability.extra.planets = (card.ability.extra.planets or 0) + 1
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_pokerhand", vars = { card.ability.extra.interval } }
						elseif
							G.GAME.blind.config.blind.key == "bl_head" then
							card.ability.extra.triggers.Hearts = card.ability.extra.triggers.Hearts + card.ability.extra
								.interval
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_h", vars = { card.ability.extra.interval } }
						elseif
							G.GAME.blind.config.blind.key == "bl_goad" then
							card.ability.extra.triggers.Spades = card.ability.extra.triggers.Spades + card.ability.extra
								.interval
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_s", vars = { card.ability.extra.interval } }
						elseif
							G.GAME.blind.config.blind.key == "bl_window" then
							card.ability.extra.triggers.Diamonds = card.ability.extra.triggers.Diamonds +
								card.ability.extra
								.interval
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_d", vars = { card.ability.extra.interval } }
						elseif
							G.GAME.blind.config.blind.key == "bl_club" then
							card.ability.extra.triggers.Clubs = card.ability.extra.triggers.Clubs +
								card.ability.extra.interval
							card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_retrigger_c", vars = { card.ability.extra.interval } }
						elseif G.GAME.blind.config.blind.key == "bl_final_heart" then
							card.ability.extra.interval = card.ability.extra.interval * 2
							card.ability.extra.last_buff = localize("k_rise_final_heart")
						elseif G.GAME.blind.config.blind.key == "bl_final_acorn" then
							if #G.jokers.cards > 0 then
								local valid_cards = {}
								for i = 1, #G.jokers.cards do
									if G.jokers.cards[i].ability.name ~= "j_tsun_tsunami_rise" then
										table.insert(valid_cards, G.jokers.cards[i])
									end
								end
								if #valid_cards > 0 then
									G.E_MANAGER:add_event(Event({
										func = function()
											local rand_card = pseudorandom_element(valid_cards, pseudoseed('risette'))
											local new_card = create_card('Joker', G.jokers, nil, nil, nil, nil,
												rand_card.config.center.key, nil)
											new_card:set_edition({ negative = true }, true)
											new_card:add_to_deck()
											G.jokers:emplace(new_card)
											new_card:start_materialize()
											return true
										end
									}))
									card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {
										message = localize('k_plus_joker'),
										colour = G.C.DARK_EDITION,
									})
									card.ability.extra.last_buff = localize("k_rise_final_acorn")
								else
									card.ability.extra.last_buff = localize("k_rise_failed")
								end
							end
						else
							local randeffect = math.random(1, 8)
							if randeffect == 1 then
								ease_hands_played(card.ability.extra.interval)
								card.ability.extra.random = "Random Buff: "
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_hand", vars = { card.ability.extra.interval } }
							elseif randeffect == 2 then
								card.ability.extra.random = "Random Buff: "
								G.hand:change_size(card.ability.extra.interval)
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_handsize", vars = { card.ability.extra.interval } }
							elseif randeffect == 3 then
								card.ability.extra.random = "Random Buff: "
								ease_discard(card.ability.extra.interval)
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_discard", vars = { card.ability.extra.interval } }
							elseif randeffect == 4 then
								card.ability.extra.random = "Random Buff: "
								SMODS.change_discard_limit(card.ability.extra.interval)
								SMODS.change_play_limit(card.ability.extra.interval)
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_psychic", vars = { card.ability.extra.interval } }
							elseif randeffect == 5 then
								card.ability.extra.random = "Random Buff: "
								ease_ante(-card.ability.extra.interval)
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_minus_ante", vars = { card.ability.extra.interval } }
							elseif randeffect == 6 then
								card.ability.extra.random = "Random Buff: "
								card.ability.extra.money = card.ability.extra.money + (card.ability.extra.interval * 3)
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_money", vars = { card.ability.extra.interval * 3 } }
							elseif randeffect == 7 then
								card.ability.extra.random = "Random Buff: "
								card.ability.extra.xmult_toggle = card.ability.extra.xmult_toggle +
									card.ability.extra.interval
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_card_xmult", vars = { card.ability.extra.interval * 1.25 } }
							elseif randeffect == 8 then
								local _hand, _tally = "High Card", 0
								for k, v in ipairs(G.handlist) do
									if G.GAME.hands[v].visible and G.GAME.hands[v].played > _tally then
										_hand = v
										_tally = G.GAME.hands[v].played
									end
								end
								for i = 1, card.ability.extra.interval do
									card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil,
										{ message = localize('k_level_up_ex') })
									update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3 },
										{
											handname = localize(_hand, 'poker_hands'),
											chips = G.GAME.hands[_hand].chips,
											mult = G
												.GAME.hands[_hand].mult,
											level = G.GAME.hands[_hand].level
										})
									level_up_hand(context.blueprint_card or card, _hand, nil, 1)
									update_hand_text({ sound = 'button', volume = 0.7, pitch = 1.1, delay = 0 },
										{ mult = 0, chips = 0, handname = '', level = '' })
								end
								card.ability.extra.random = "Random Buff: "
								card.ability.extra.last_buff = localize { type = "variable", key = "k_rise_pokerhand2", vars = { card.ability.extra.interval } }
							end
						end
					end
					if context.repetition and context.cardarea == G.play then
						if context.other_card.ability_name == "Wild Card" then
							local triggersum =
								card.ability.extra.triggers.Hearts +
								card.ability.extra.triggers.Spades +
								card.ability.extra.triggers.Diamonds +
								card.ability.extra.triggers.Clubs
							return {
								message = localize('k_again_ex'),
								repetitions = triggersum,
								card = card
							}
						elseif context.other_card:is_suit("Hearts") and card.ability.extra.triggers.Hearts >= 1 then
							return {
								message = localize('k_again_ex'),
								repetitions = card.ability.extra.triggers.Hearts,
								card = card
							}
						elseif context.other_card:is_suit("Spades") and card.ability.extra.triggers.Spades >= 1 then
							return {
								message = localize('k_again_ex'),
								repetitions = card.ability.extra.triggers.Spades,
								card = card
							}
						elseif context.other_card:is_suit("Diamonds") and card.ability.extra.triggers.Diamonds >= 1 then
							return {
								message = localize('k_again_ex'),
								repetitions = card.ability.extra.triggers.Diamonds,
								card = card
							}
						elseif context.other_card:is_suit("Clubs") and card.ability.extra.triggers.Clubs >= 1 then
							return {
								message = localize('k_again_ex'),
								repetitions = card.ability.extra.triggers.Clubs,
								card = card
							}
						end
					end
					if context.individual and context.cardarea == G.play and card.ability.extra.xmult_toggle >= 1 then
						return {
							x_mult = card.ability.extra.interval * (1.25 ^ card.ability.extra.xmult_toggle),
							card = card
						}
					end
					if context.after then
						rs_pokerhand = context.scoring_name
					end
					if context.end_of_round and context.main_eval and card.ability.extra.planets > 0 then
						for i = 1, (card.ability.extra.planets * card.ability.extra.interval) do
							G.E_MANAGER:add_event(Event({
								trigger = 'before',
								delay = 0.0,
								func = (function()
									if rs_pokerhand then
										local _planet = 0
										for k, v in pairs(G.P_CENTER_POOLS.Planet) do
											if v.config.hand_type == rs_pokerhand then
												_planet = v.key
											end
										end
										local card2 = create_card(card_type, G.consumeables, nil, nil, nil, nil, _planet,
											'blusl')
										card2:add_to_deck()
										card2:set_edition({ negative = true }, nil)
										G.consumeables:emplace(card2)
										G.GAME.consumeable_buffer = 0
									end
									return true
								end)
							}))
							card:juice_up()
							card_eval_status_text(card, 'extra', nil, nil, nil,
								{ message = localize('k_plus_planet'), colour = G.C.SECONDARY_SET.Planet })
						end
					end
				end
			end
		end
	}

	FusionJokers.fusions:add_fusion("j_splash", nil, false, "j_tsun_tsunami_rise", nil, false, "j_tsun_gold_tsunami_rise",
		50)







	--- this end is for the gold jokers config check DO NOT REMOVE IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
end
